<resources>
    <string name="app_name">BCA 4 Sem</string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="traid">\n “TRIAD” \n\n A computer system can be defined as a TRIAD comprising of three fundamental components:\n
(1) The CPU (2) The Memory and (3) The I/O \n\n
These three devices communicates with each other with the help of a set of wires called System Bus,
where the System Bus comprises of three buses as –\n
1. The Address Bus\n
2. The Data Bus and\n
3. The Control Bus.\n\n
A computer system requires an interface with the user to execute a program. The interaction is
accomplished with the help of I/O devices. (The Input – Output subsystem of a computer, referred to
as I/O, provides an efficient mode of communication between the central system and the outside
environment).\n\n</string>
    <string name="IOheading"><u><b>Input – Output Architecture</b></u> \n\n
A computer system organization is defined as a collection of component connected together in a
logical sense, i.e. the logical structure of a computer system is termed computer organization.
The collection of physical component such as CPU, Memory, I/O arranged constitutes computer
architecture. Thus the physical definition of the system is architecture.
\n\n
Organization = Logical\n
Architecture = Physical\n\n</string>
    <string name="systemHeading">\nThe I/O devices are connected to an entity called an interface (I/F) to have
            an interaction with the system.\n\n</string>
    <string name="organisation">\n
     <u>  <b>Organization and Architecture→</b></u> \n\n
In describing computer system, a distinction is often made between computer architecture and
computer organization. Computer architecture refers to those attributes of a system visible to a
programmer or put another way, those attributes that have a direct impact on the logical execution
of a program. Computer organization refers to the operational units and their interconnections that
realize the architectural specifications. Example of architectural attributes include the instruction
set, the number of bits used to represent various data types (e.g. numbers, characters), I/O
mechanisms, and techniques for addressing memories. Organizational attributes include those
hardware details transparent to the programmer, such as control signals, interface between the
computer and peripherals and the memory technology used.
Register transfer language\n
A digital system is an interconnection of digital hardware modules combined together to
perform a specific processing task. The modules are constructed using registers ,decoders,
arithmetic elements and control logic. These various modules are interconnected with
common data and control paths to form a digital computer system.\n
A digital module can be best defined as the register it contains and the operations that are
performed on the data stored in them. The operations executed on data stored in registers
are called micro operations. A micro-operation is defined as an elementary operation
carried out on one clock pulse, over the information stored in one or more registers.eg.
shift, count, clear load.\n
The organization of a digital computer can be best defined by:\n
1)The set of registers it contains and their function\n
2)sequence of micro-operations performed on the data stored in the registers\n
3)control functions that initiate the sequence of micro-operations.\n
The symbolic notations used to describe the micro-operation transfers among registers is
called a register transfer language. As a programming language is a procedure for writing
symbols to specify a given computational process similarly a register transfer language ia a
system for expressing the micro-operation sequences in a symbolical form among the
registers of a digital module. Unlike a programming language; a register transfer language is
directly related to and cannot be separated from the registers and other hardware that it
defines.\n\n
\n\n<u><b>INTER-REGISTER TRANSFER</b></u>
Data transfer among registers is accomplished by means of inter-register transfer microoperations. These micro-operations perform a direct transfer of binary information from
one register to another. The destination register receives the information from the source
register retaining the contents in source register.\n
Information transfer from one register to the another can be performed either in parallel or
in serial.\n\n
        <u><b>Parallel transfer</b></u>\n\n
Parallel transfer is a simultaneous transfer of all bits from the source register to destination
register and is accomplished during one clock pulse. This micro-operation is designated in
symbolic form as follows:\n\n
A←B\n\n
And denotes a transfer of the content of register B into register A.The binary function which
determines when this transfer will take place is called a control function.A control function
is a binary function that is it can be either equal to 0 or 1.Thus the modified symbology for
the above transfer can be written as\n\n
P:A←B\n\n
The control function P symbolizes the fact that the stated micro-operation is executed by
the hardware only if P=1.\n</string>

    <string name="Basic_symbol">Understanding the basic symbols for the register transfer language\n\n
1. Capital letters are used to denote registers and subscripts denote individual cells of the register.eg A, B.\n\n
2.Paranthesis used to denote a portion of a register.eg. I (1-5), MBR(AD)\n\n
3.Arrow must be present in every micro-operation statement and denotes a transfer of the content of the register listed on the right side of the arrow into the register listed on the left side of the arrow.\n\n
4.Colon denotes a control function and the comma is used to separate two or more micro-operations when executed at the same time.\n
        Eg. F:A←B,B←A\n\n

        <b>SERIAL TRANSFER</b>\n\n
For serial transfer, both the source and destination registers are shift-registers.The information is transferred one bit at a time by shifting the bits out of the source register into the destination register. In order not to lose the information stored in the source register it is necessary that the information shifted out of the source register be circulated and shifted back at the same time.\n\n
The serial transfer of information from Reg B to Reg A is done with shift registers as shown in the block diagram of fig 2.Both the registers A and B are 4-bit registers.The serial output of reg B comes from the output of the rightmost flip-flop B4 .The serial input of reg A goes into the left-most flip-flop A1.When the shift-right control S=1,and a clock pulse occurs,the content of reg A and B are shifted once to the right and the value of B4 transferred to flip-flops A1 and B1.Due to this one bit is transferred from B to A and at the same time one bit is circulated back to reg B.\n\n

        The symbolical notation for the transfer is as follows:\n\n
S:A1←B4,B1←B4,Ai←Ai-1,Bi←Bi-1   where, i=2,3,4\n\n
S:A←B,B←B\n\n
    </string>
    <string name="Bus_transfer">\n\n<b>BUS TRANSFER</b>\n\n
In a system with N registers, the transfer from each register to another register requires lines to be connected from the output of each flip-flop in the source register to input of each flip-flop in the destination register.\n
The fig below shows transfer of data among 3 registers R1, R2, R3. There are six data paths between these 3 registers. If each register consists of N flip-flops, there is a need of 6n lines for parallel transfer from one reg to another. As the number of register increases the number of lines also increases many-folds.\n\n
    </string>
    <string name="below_bus">However, if one register is allowed to transfer at a time, we can reduce the number of lines as shown in the next fig where the output and input of each flip-flop of the register is connected to a common line through an electronic circuit that acts like a switch. All the switches are OPEN until a transfer is required. For a transfer of R1R3, switch S3 when closed transfers data from R3 to BUS and then switch S6 when closed transfers the data from BUS to R1.
This scheme can be extended to registers with n flip -flops and require n common lines since each flip-flop of the register must be connected to one common line.\n\n
Bus system of data transfer using four registers\n\n
A group of wires through which binary information is transferred among registers is called a BUS.\n\n
A bus system is formed with multiplexer circuits. A multiplexer selects data from many lines and directs it to a single output line. The fig shows how four registers are connected through multiplexers to form one set of common bus lines. Each register has 4 bits. Each 4X1 multiplexer has four data input lines, two selection lines, and one output line. Reg A is connected to I0 of the multiplexers, Reg B to I1 and so forth. The selection lines act as control to all the multiplexers such that if xy =00, multiplexer inputs I0 are selected and transferred to the output bus, i.e. 4-bit contents of reg A are transferred to the common bus. Activating the load input of a particular register will cause a transfer of information from the bus into register. When zw=00/01/10/11 then data gets transferred from bus to resp registerA/B/C/D.\n\n
        xy =10 : BUS←C\n\n
        zw=01 : R1(A)←BUS\n\n
    </string>
    <string name="memory_transfer">\n<b>Memory Transfer</b>\n\n
The transfer of information from memory to the external environment is called a Read Operation.\n\n
The transfer of information into the memory is called a write operation. In both operations, the particular memory word selected must be specified by an address. MAR a memory address register is connected to the address terminals of the memory.\n\n
A read micro-operation is a transfer from the selected memory register M into MBR.\n\n
MBR←M\n\n
This causes a transfer of one word into MBR from the selected mem reg M whose address is given by the address in MAR.\n\n</string>


    <string name="A_write_micro_operation">\n A write micro-operation is a transfer from MBR to the selected memory word M.This is shown symbolically as\n\n
M←MBR\n\n
This causes the transfer of a word from MBR into the mem reg M whose address is given by the address in MAR.\n\n
MBR←M[R1]\n\n
Denotes a read operation from the memory word whose address is specified by the reg R1.\n\n

ARITHMETIC MICRO-OPERATIONS\n\n
ALU (Arithmetic and Logic Unit) –\n\n\n
        <b>Arithmetic Circuit:</b>\n\n</string>

    <string name="The_ALU">\n
The ALU, Arithmetic and Logic Unit carry out the arithmetic and logic functions over the content of operands stored in register and memory. The general arithmetic functions are: addition, subtraction, increment, decrement etc.; whereas negotiation, AND, OR, XOR are the general logical operations that are carried out by this unit. An ALU is associated with a set of micro – instructions where every micro – instruction carried out a specific task.\n\n
</string>

    <string name="Arithmetic_Circuit">\n
<b>Arithmetic Circuit:</b> A binary parallel adder can be used to perform some fundamental arithmetic operation over the operands. Thus, a simple arithmetic circuit can be constructed with the help of parallel adder and by providing different inputs in form of A, B and Ci, many arithmetic operations can be carried out. Some fundamental arithmetic operations can be obtained by a parallel adder is shown in figure –\n\n
</string>

    <string name="Logic">\n
        <b><u>Logic Circuit:</u></b></string>

    <string name="Logic_Circuit">\n
<b><u>Logic Circuit:</u></b> A logic unit basically carries out logical operations over the content of CPU registers. The given figure illustrates a simple logic circuit created with the help of some fundamental gates and a multiplexer. The circuit accepts two inputs Ai and Bi (a bit of value A and value B) and with reference to control S1 and S0, perform a relevant logic operations as depicted in table. When S1, S0 equals 00, the unit produces A.B output.\n\n

This one stage of the logic circuit can be repeated n number of times to carry out logic operation over n – bit data.\n\n

<u><b>Truth table for 16 functions of two variables</b></u>
</string>

    <string name="F0">\n
F0=All 0’s \n\n
F1=x and y \n\n
F2=xy’ \n\n
F3=xy’+xy=x(y+y’)=x \n\n
F4=x’y \n\n
F5=x’y+xy=y(x’+x)=y \n\n
F6=x xor y \n\n
F7=x or y \n\n
F8=x nor y \n\n
F9=x xnor y \n\n
F10=x’y’+xy’=y’(x’+x)=y’ \n\n
F11=x’y’+xy’+xy=y’+xy \n\n
F12=x’y’+x’y=x’(y’+y)=x’ \n\n
F13=x’y’+x’y+xy=x’+xy \n\n
F14=x nand y \n\n
F15=All 1’s \n\n

<u><b>Arithmetic and Logic Unit –</b></u>\n\n
</string>

    <string name="The_ALU_can">\n
The ALU can be constructed by simply combining the arithmetic unit along with the logic unit to carry out the arithmetic and logic operations. Figure illustrate a typical ALU where it comprises of one stage of arithmetic unit and one stage of logic unit connected to a 2x1 multiplexer. The circuit now has an additional control S2 which selects one of the operation i.e., arithmetic or logic produced at output. On whole the circuit now comprises of three controls S2, S1 and S0 that selects a arithmetic or logic operation. The arithmetic operation selection is also depending on the carry input Ci. The table below shows all the operations that are carried out in the above circuit.\n\n
</string>


<string name="CONTROL_FUNCTIONS">\n
<u><b>CONTROL FUNCTIONS</b></u>\n\n
    The timig of all registers in a synchronous digital system is controlled by a master clock generator,whose clock pulse are applied to all flip-flops in the system. The binary variables that control the enable inputs of registers are called control functions.\n\n
    The hardware control network that generates control functions can be organized in three different ways\n\n
    1) As a sequential circuit\n
    2) As a sequence of timing signals coupled with control conditions\n
    3) As a control memory\n\n
    <u><b>TIMING SEQUENCES</b></u>\n\n
    Timing signals that control the sequence of operations in a digital computer can be generated with a binary counter and a decoder.\n\n
    </string>

    <string name="Generation">\n
<u><b>Generation of control functions</b></u>\n\n

    \n\n
    Each computer cycle is associated with a sequence of micro-operations. These micro-operations are controlled by the timing signals and other binary conditions in the system .The Boolean functions that generate the control decisions are the control functions.For eg\n\n
    T1: MBR←M\n\n
    T1=read-control input for memory unit\n\n
    FT1+R’T3: A←B\n\n
    The control function being a Boolean function can be generated with logic gates as shown in the fig below. The gates that generate the control function go to the load input of reg A to initiate the transfer. The condition may also initiate the same transfer.\n
</string>

    <string name="BASIC_COMPUTER">\n
<u><b>BASIC COMPUTER ORGANIZATION AND DESIGN</b></u>\n\n
    <b>Instruction codes</b>\n\n

    The internal organization of a computer system is defined by the sequence of micro-operations it performs on data stored in registers. A digital computer is a general purpose digital system. The user of such a system can control the process by means of a
    program, that is a set of instructions that specifies the operations, operands and the sequence by which processing has to occur.\n\n
    An instruction code is a group of bits that tell the computer to perform a specific operation. It is usually divided into more than one field ,the most basic of them being the operation field. The operation field specifies operations such as add, sub, shift left, logical and etc.\n\n
    At this point we must clearly understand the relation between an operation and a micro-operation. An operation is a part of an instruction stored in computer memory. It is a binary code that tells the computer to perform a specific operation. The control unit receives the instruction from memory and interprets the operation code bits. It then issues a sequence of control functions that perform micro-operations in internal computer registers. For every operation code, the control issues a sequence of micro-operations needed for the hardware implementation of the specified operation. Due to this reason operation code is also referred to as macro-operation because it specifies a set of micro-operations.\n\n
    Fig depicts an organization. Instructions are stored in one section of memory and data in another. For a memory unit with 4096 words we need 12 bits for address since 212 =4096. If we store each instruction code in one 16-bit memory word, then we have four bits available for 16 possible operations and 12 bits to specify the address of the operand over which the operation will execute.\n\n
</string>

    <string name="Demonstration">\n
<u><b>Demonstration of direct and indirect instructions</b></u>\n\n

    It is sometimes convenient to use the address bits of an instruction code not as an address but as the actual operand. When the second part of an instruction code specifies an operand, the instruction is said to have an immediate operand. When the second part specifies the address of an operand, the instruction is said to have a direct address. The third possibility is an indirect address, where the bits in the second part of the instruction designate an address of a memory word in which the address of the operand is found. The MSB generally differentiates between a direct or an indirect instruction format.\n\n
    To illustrate the concept let us take an example of an instruction code format\n\n
    It consists of a three-bit operation code designated by OP, a six-bit address part designated by AD, and an indirect-address mode designated by I. If I=0 it designates a direct address and if a 1 indicates indirect address.\n\n
    A direct address instruction is shown in fig.2(b). It is placed in address 2 in memory. The I bit is 0,so the instruction is recognized as a direct address instruction. Since the address part Ad is equal to binary equivalent of 9(001001),the control finds the operand in memory at address 9. In fig 2(c) I=1 ,therefore it is a indirect address instruction. The address part is 9 so the control goes to 9 and finds the address of operand. The indirect address instruction needs two references to memory to fetch an operand.\n\n
</string>

    <string name="Computer_Instructions">\n
<u><b>Computer Instructions</b></u>\n\n

    Computer instructions are stored in consecutive memory locations and are executed sequentially one at a time. The control reads an instruction from a specific address in memory and executes it and then continues onto the next instruction in sequence and so on. Memory words cannot communicate with the processor directly without going through an address and buffer register. It is also necessary to provide a register in control unit for storing operation codes after they are read from memory.\n\n
</string>

    <string name="The_memory">\n

The memory unit has a capacity of 4096 words and each word contains 16 bits. Twelve words are needed to specify the address of an operand. This leaves four bits for the operation part of the instruction. However, only 3 bits will be used to specify the operation code. Where the fourth bit will be used as a direct an indirect address bit. The memory buffer register (MBR) consists of 16 bits ,as does the accumulator register. The E register is an extension of the accumulator and will be used during shift operations for end around carry. The I register has a single cell for storing the mode bit and the operation register OPR stores the three-bit operation code from memory.\n\n
The memory address register (MAR)has 12 bits storing the 12 bit of the address. The program counter(PC) is also 12 bit long since it stores the address of the next address to be fetched by the processor. This register goes through a counting sequence and causes the computer to read sequential instructions stored in memory.\n\n
To read an instruction, the content of PC is transferred to MAR, a memory read cycle is initiated, and the PC is incremented by 1.This place the instruction code into MBR and prepares PC for the address of the next instruction. The operation code is transferred to OPR, the mode bit into I and the address part into MAR.\n\n
The basic computer has three different instruction code formats. The operation part contains three bits; the meaning of the remaining thirteen bits depends on the operation code encountered.\n\n
</string>

    <string name="A_computer_should">\n
A computer should have all the necessary and sufficient operations to carry out any conceivable processing task. It should contain instructions in each of the following categories:\n\n
1. Arithmetic, logic, and shift micro operations\n
2. Instructions for moving info to and from memory and processor registers\n
3. Instruction that check status info to provide decision making capabilities.\n
4. Input and output instructions.\n
5. The capability of stopping computer.\n\n

<b>TIMING and CONTROL</b>\n\n

When an instruction is read from memory, the computer is said to be in an instruction fetch cycle. When the word read from memory is an address of an operand the computer is in an indirect cycle. When the word read from the memory is an operand, the computer is in a data execute cycle. It is the function of the control to keep track of the various cycles.\n\n
The control unit uses two flip-flops to distinguish between the three cycles. These flip-flops are denoted by the letters F and R. A 2X4 decoder associated with these flip-flops provide four outputs , three of which can be used to differentiate between the above mentioned cycles.\n\n
The block diagram of the control unit for the basic computer is show in fig. The timing in the computer is generated by a 2-bit sequence counter(SC) and a 2X4 decoder. The timing signals out of the decoder are designated by t0,t1,t2 and t3.\n\n
</string>

    <string name="TIMING"><u><b>TIMING and CONTROL</b></u>\n\n</string>

    <string name="A_digital">\n
A digital computer operates over a given set of instructions to accomplish a problem solution. The instruction comprises of a sequence of micro operations that are needed to be carried out when the instruction is executed.\n\n
The unit of CPU that generates the sequence of micro operations for a given instruction is termed timing and control unit. A simple computer system CPU comprises of four machine cycle: Fetch Cycle, Indirect Cycle, Execute Cycle and Interrupt Cycle.\n\n
Figure illustrates a typical control unit block diagram. It consist of a control logic circuit associated with several functional blocks generating various control functions for a given instruction. It consists of following:\n\n
1. 3 x 8 Decoder: It accepts the three bit operation code of instruction and accordingly generate control signals q0……….q7. For example, if OPr is 011 than q3 is enable.\n\n
2. I: It is the indirect flip – flop that accept a value from I field of instruction. If I is 1 than q7 is determine. If q7 is 1 than an I–O instruction is carried out. If I is 0 and q7 is 1 than a register operation is carried out.\n\n
3. 2 x 4 Timing Decoder: This decoder provides four clocks t0 – t3, i.e., every cycle comprises of four clocks. This decoder is driven by the sequence counter SC and by a enable flip – flop S. if S is 1 than only the cycle is executed.\n\n
4. 2 x 4 Decoder (Control 2 x4 Decoder): This decoder accepts F and R bits and depending on their values generates the respective cycle as depicted in table.\n\n
C0 t0 : MAR ← PC\n\n
C0 t1 : MBR ← M, PC ← PC + 1\n\n
C0 t2 : OPR ← MBR (OP), I ← MBR (2)\n\n
q\'7 IC0t3 : R ← 1\n\n
(q7 + I\’) C0t3 : F ← 1\n\n</string>
    <string name="Fetch_Cycle">\n
<b>Fetch Cycle:</b> It is the first machine cycle of every instruction cycle. The task of this cycle is to fetch the instruction from the memory, to decode it and then to call the relevant machine cycle as either executes cycle or indirect cycle. The various tasks performed in fetch cycle at different clocks are shown above. In first clock to the content of program counter is transfer to MAR. In second clock t1, two tasks are carried out, i.e. the program counter is incremented by one as well as the memory location is read out in MBR. In third clock t2, the I and OP fields are filled up from fetched instruction. In fourth clock t3, the design is taken to call indirect cycle or execute cycle. This design is based on q7 and I. if q7 = 0 and I = 1 then indirect cycle is called else the execute cycle is called.\n\n
<b>Indirect cycle:</b>\n\n

C1 t0 : MAR ← MBR (ADDR)\n\n
C1 t1 : MBR ← M\n\n
C1 t2 : NOP\n\n
C1 t3 : F ← 1, R ← 0\n\n</string>

<string name="The_indirect">\n
The indirect cycle is used to fetch the address of operand. The indirect cycle receives the pointer value from fetch cycle. In the given machine C1 represents the indirect cycle. On the first clock of this machine cycle the address part obtained from the fetch cycle is used to get the address of operand, it is done in second cycle. The third cycle is NOP (No OPeration). The fourth cycle is used to call the execute cycle.\n\n

<u>ADD to AC (Accumulator)</u>\n\n
q1 C2 t0 : MAR ← MBR (AD)\n\n
q1 C2 t1 : MBR ← M\n\n
q1 C2 t2 : EAC ← AC + MBR\n\n
q1 c2 t3 : Fetch Cycle Call\n\n
<b>Instruction Cycle:</b>
An instruction cycle is a composition of various machine cycles. The general machine cycles are:\n\n
1. Fetch instruction\n\n
2. Decode instruction\n\n
3. Fetch Operand if any\n\n
4. Store results.\n\n
Every machine cycle in term is a composition of clocks where on each clock micro operations are carried out.\n\n
</string>

    <string name="Interrupts"><u>Interrupts</u> –\n
An interrupt is a signalling mechanism by which the external entity or the internal program itself can as the CPU to perform some special services that are dedicates routines or called Interrupt Service Routine (ISR).\n\n
A computer system comprises of two types of interrupt called the Hardware Interrupt and Software Interrupt. The interrupt that are generated over the pin of a CPU (Microprocessor) are termed hardware interrupt whereas the interrupt generated programmatically are termed software interrupt.\n\n
The interrupt may be vector or non – vector. If the service routine address of an interrupt is fixed that is assign with a fixed address than is called a non – vector interrupt else if the address of interrupt is provided by the interrupting device than it is called a vector interrupt.\n\n
Figure illustrates a flow chart for interrupt handling. Initially the CPU waits for an instruction. When an instruction is submitted the fetch and execute cycles are performed i.e. the instruction cycle is carried out. At the end of instruction cycle the interrupt status is checked. If more than one interrupts are there than their priority are resolved and the interrupt with highest priority is served.\n\n
Calling an executive interrupt service routine:\n\n
Once the interrupt is identified the CPU saves the content of register onto the stack, transfer the control to ISR, disable interrupts, and services interrupt enable the interrupt and reload the saved register values and contents.\n\n
</string>

    <string name="graphics_unit1_firstsagment">
    what is computer Graphics\n
computer graphics is use of computer to define store manipulate,
introgate  and present the pictorial output
                          OR\n

computer graphics means creation,storage and manipulation of models come
from many fields incuding physical ,mathematical,artistics and biological structure\n

<b><u>Types:-</u></b>\n
        *Interactive computer graphics +++++++)) a two way communication between the computer
and the user ,where the observer is given some control over the image by providing
an input device example video games  \n\n

        <b>* Non -Interactive computer graphics (passive computer graphics)-</b>\n
here  the user does not have any kind of control over the image .
the image is product of static stored program and will work according to
the instructions given in the program .here the image is totally
under the control of program intruction not under the user
Example - screensaver.
\n\n

        <u>pixel:-</u> the smallest addressable screen element or smallest addresabale area which we can
can control on the screen at some point of time is called pixel
\n\n
<u>Resolution:- </u>the number of pointss that can be displayed without
overlapping each other on the screen is defined as resolution
\n\n\
It is also defines the quality of graphics
        \n
Aspect ratio :- it is a ratio of vertical lenght by horizontal length
of any object in term of the number of pixel persent


    </string>
    <string name="graphics_workstation">Graphics workStation :-</string>
    <string name="second_segment_workstation_graphics">-it is a graphical kernal system (gks) term for a graphical
device that can display graphical output and accept graphical
input\n
-It consists of cpu ,display,processer ,memory,display device
,recoder,plotter,keyboard,mouse,scanner,etc..\n
-Thev main hardware component of a graphics workstation are
cpu and display processor.\n
-The display processor is also called graphics controller or a
a diplay co-processor.\n
-It makes cpu free from the graphical work.\n
-In addition to the system memory a seperate display procesor
 memory area is provided.\n
- The graphical workstation have a provision to interface
videogame and television set\n
- They also have display devices with very high resolution and
veru high performance cpu.\n
-The graphical workstation is always supported with graphical
software\n
.

Framebuffer-\n\n
A frame buffer is a secondary memory buffer used to construct a video frame before it is displayed on a
screem surface.\n

# It is an area of memory used to hold the frame of data that
 is continusly being send to the screen .\n
# The buffer is the size of maximum image that can be displayed and
  may be a seprate memory bank on the graphics card or a reserved part of regular
memory.\n
        #framebuffer is represented by an array which collects and store the intensity value
for all the pixel\n
# This array is accesed by the display device to determine the intensity at which 
each pixel should be displayed\n
         Therefor, a frame buffer contains internal representation of pixel
</string>
    <string name="firstsegmentvbunit1">
      <u><b> *DOT NET Framework</b></u>\n:-
        The .Net framework is a software development platform developed by Microsoft. The framework was meant to create applications,
        which would run on the Windows Platform. The first version of the .Net framework was released in the year 2002.\n
        The version was called .Net framework 1.0. The .Net framework has come a long way since then, and the current version is 4.7.1.\n\n

        <u>The .Net framework can be used to create both </u>- Form-based and Web-based applications. Web services can also be developed using the .Net framework.\n

         The framework also supports various programming languages such as Visual Basic and C#. So developers can choose and select the language
        to develop the required application. In this chapter, you will learn some basics of the .Net framework.\n\n




  * <b><u>Overview and Base Class Library</u></b>:-\n
The Framework Class Library or FCL provides the system functionality in the .NET Framework as it has various classes, data types, interfaces, etc. to perform multiple
functions and build different types of applications such as desktop applications, web applications, mobile applications, etc. The Framework Class Library is integrated
 with the Common Language Runtime (CLR) of the .NET framework and is used by all the .NET languages such as C#, F#, Visual Basic .NET, etc.\n\n

        <b>Categories in the Framework Class Library</b>>:-\n
    The functionality of the Framework Class Library can be broadly divided into three categories i.e utility features written in .NET, wrappers around the
        OS functionality and frameworks. These categories are not rigidly defined and there are many classes that may fit into more than one category.
Framwork-Class-Library-FCL-in-Dot-NET


<u>Details about the Categories in the Framework Class Library are given as follows</u>:\n\n

        1)<b>Utility Features</b>:- The utility features in the FCL includes various collection classes such as list, stack, queue, dictionary, etc. and also classes for more varied manipulations such as Regex class for regular expressions.\n

2)<b>Wrappers Around OS functionality</b>:- Some of the features in the FCL are wrappers around the underlying Windows OS functionality. These include the classes for using the file system, the classes to handle the network features, the
classes to handle I/O for console applications, etc.\n

3)<b>Frameworks</b>:- There are various frameworks available in the FCL to develop certain applications. For example, ASP.NET is used to develop web applications, Windows Presentation Foundation (WPF) is used to render user interfaces in
Windows applications and so on.\n\n




* <u><b>MSIL</b></u>:-\n MSIL stands for Microsoft Intermediate Language. We can call it as Intermediate Language (IL) or Common Intermediate Language (CIL). During the compile time , the compiler convert the source code into Microsoft Intermediate
Language (MSIL) .Microsoft Intermediate Language (MSIL) is a CPU-independent set of instructions that can be efficiently converted to the native code. \n\n



* <u><b>Common Language Run Time (CLR)</b></u>\n:-
CLR is the basic and Virtual Machine component of the .NET Framework. It is the run-time enviornment in the .NET Framework that runs the codes and helps in making the development process easier by providing the various services.
Basically, it is responsible for managing the execution of .NET programs regardless of any .NET programming language. Internally, CLR implements the VES(Virtual Execution System) which is defined in the Microsoft’s implementation
 of the CLI(Common Language Infrastructure).The code that runs under the Common Language Runtime is termed as the Managed Code. In other words, you can say that CLR provides a managed execution enviornment for the .NET programs
by improving the security, including the cross language integration and a rich set of class libraries etc. CLR is present in everyn .NET framework verison\n\n</string>
    <string name="second_segment_vb_unit1">
        * <b><u>Events</u></b>:-\nAn event is an action or occurrence such as a mouse click, a key press, mouse movements, or any system-generated notification. A process communicates through events. For example, interrupts are system-generated events.
 When events occur, the application should be able to respond to it and manage it.\n\n



* <b><u>.NET Assemblies</u></b>:-\nAssemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.
 An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.
 Assemblies take the form of executable (.exe) or dynamic link library (.dll) files, and are the building blocks of .NET applications.
 They provide the common language runtime with the information it needs to be aware of type implementations.\n

In .NET Core and .NET Framework, you can build an assembly from one or more source code files. In .NET Framework, assemblies can contain one or more modules.
This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.\n\n
Assemblies have the following properties:\n\n

1.Assemblies are implemented as .exe or .dll files.\n

2.For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the global assembly cache (GAC). You must strong-name assemblies before you can include them in the GAC. For more information, see Strong-named assemblies.\n

3.Assemblies are only loaded into memory if they are required. If they are not used, they are not loaded. This means that assemblies can be an efficient way to manage resources in larger projects.\n

4.You can programmatically obtain information about an assembly by using reflection. For more information, see Reflection (C#) or Reflection (Visual Basic).\n

5.You can load an assembly just to inspect it by using the MetadataLoadContext class in .NET Core and the Assembly.ReflectionOnlyLoad or Assembly.ReflectionOnlyLoadFrom methods in .NET Core and .NET Framework.\n\n\n


In .Net 3 types of Assemblies are available:\n\n

        1. <u>Private Assemblies</u> : Private Assemblies are designed to be used by one application and
                                   must reside in that application\'s directory or subdirectory. \n

        2. <u>Shared Assemblies</u>: Microsoft offers the shared assembly for those components that must
                                  be distributed. It centered around two principles.
                                  Firstly, called side-by-side execution, allows the CLR to house multiple
                                  versions of the same component on a single machine.
                                  Secondly, termed binding, ensures that clients obtain the version of the
                                  component they expect. \n

        3. <u>Satellite Assembly</u>: A satellite Assembly is defined as an assembly with resources only, no
                                 executable code.\n

        * <b><u>Advantages of Assemblies over Predecessors</u></b>:-\n
Assemblies are designed to simplify application deployment and to solve versioning problems that can occur with component-based applications.\n
End users and developers are familiar with versioning and deployment issues that arise from today\’s component-based systems. Some end users have
experienced the frustration of installing a new application on their computer, only to find that an existing application has suddenly stopped working.
 Many developers have spent countless hours trying to keep all necessary registry entries consistent in order to activate a COM class\n
Many deployment problems have been solved by the use of assemblies in the .NET Framework. Because they are self-describing components that have no
dependencies on registry entries, assemblies enable zero-impact application installation. They also simplify uninstalling and replicating applications.
\n\n\n

        * <u><b>Dynamic Link Library (DLL)</b></u>>:-\n
A DLL is a library that contains code and data that can be used by more than one program at the same time. For example, in Windows operating systems,
the Comdlg32 DLL performs common dialog box related functions. Therefore, each program can use the functionality that is contained in this DLL to implement
an Open dialog box. This helps promote code reuse and efficient memory usage.\n
By using a DLL, a program can be modularized into separate components. For example, an accounting program may be sold by module. Each module can be loaded
into the main program at run time if that module is installed. Because the modules are separate, the load time of the program is faster, and a module is
only loaded when that functionality is requested.\n
Additionally, updates are easier to apply to each module without affecting other parts of the program. For example, you may have a payroll program, and the tax
rates change each year. When these changes are isolated to a DLL, you can apply an update without needing to build or install the whole program again.\n\n

        *<u><b>Namespaces</b></u>:-\n
Namespace is logical division of class, structure and interface OR way to organize your Visual Basic .NET code is through the use of namespaces.\n
Namespaces are a way of grouping type names and reducing the chance of name collisions.\n
The namespace with all the built-in functionality comes under System namespace. All other namespaces comes under this System namespace.\n\n

Declaration of Namespaces:\n
// Namespace Declaration in C#
using System;
using System.Data;
// Namespace Declaration in VB\n
imports system;\n
imports system.Data;\n\n
        <u><b>*Visual Studio IDE</b></u>:-

    </string>
    <string name="arrayvbunit3">An array stores a fixed-size sequential collection of elements of the same type. An array is
        used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n
        All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element\n\n\n</string>
    <string name="declaringarray">
    To declare an array in VB.Net, you use the Dim statement. For example\n
    1) Dim intData(30)	  — an array of 31 elements\n
    2)Dim strData(20) As String	— an array of 21 strings\n
    3)Dim twoDarray(10, 20) As Integer	—a two dimensional array of integers\n
        4)Dim ranges(10, 100)	 —a two dimensional array\n\n\n
    You can also initialize the array elements while declaring the array. For example:-\n\n
        Dim intData() As Integer = {12, 16, 20, 24, 28, 32}\n
        "Dim names() As String = {\"mohit\",\"navdeep\"}"\n\n


    </string>
    <string name="dynamic_arrays"><B><U>Dynamic Arrays</U></B></string>
    <string name="dynamicarray">
        Dynamic arrays are arrays that can be dimensioned and re-dimensioned as par the need of the program.
        You can declare a dynamic array using the ReDim statemen\n
       Syntax for ReDim statement −\n
        ReDim [Preserve] arrayname(subscripts)\n
        Where,\n\n
        The Preserve keyword helps to preserve the data in an existing array, when you resize it.\n
        <B>arrayname</B> is the name of the array to re-dimension\n
             subscripts specifies the new dimension.\n\n



    </string>
    <string name="test"><B><u>arrayname</u></B> is the name of the array to re-dimension</string>
    <string name="array"><B><u>Array</u></B></string>

    <string name="creating_array_in_vb_net"><b><u>Creating array in vb.net:-</u></b>\n\n</string>
    <string name="arrayclass"><b><u>The Array Class</u></b>\n
     The Array class is the base class for all the arrays in VB.Net. It is defined in the System namespace. The Array class provides various properties and methods to work with arrays.\n
        <u>Properties of the Array Class:-</u>\n
The following table provides some of the most commonly used properties of the Array class −\n\n

    </string>
    <string name="adonet">ADO.NET provides a bridge between the front end controls and the back end database. The ADO.NET objects encapsulate all the data access operations and the controls interact with these objects to display data, thus hiding the details of movement of data.\n\n
    The following figure shows the ADO.NET objects at a glance:\n


    </string>
    <string name="unit2vbvar">A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in VB.Net has a specific type, which determines the size and layout of the variable\'s memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.\n
        We have already discussed various data types. The basic value types provided in VB.Net can be categorized as \n\n
        1)Integral types	    :- SByte, Byte, Short, UShort, Integer, UInteger, Long, ULong and Char\n
        2)Floating point type :- Single and Double\n
        3)Decimal types       :- Decimal\n
        4)Boolean types       :-True or False values, as assigned\n
        5)Date types	   :-Date\n\n\n
        VB.Net also allows defining other value types of variable like Enum and reference types of variables like Class. \n\n











    </string>
    <string name="variable_declaration_in_vb_net">Variable Declaration in VB.Net</string>
    <string name="vardeclarationunit2">The Dim statement is used for variable declaration and storage allocation for one or more variables. The Dim statement is used at module, class, structure, procedure or block level.\n\n
    Syntax for variable declaration in VB.Net is −\n
        [  attributelist ] [ accessmodifier ] [[ Shared ] [ Shadows ] | [ Static ]]\n
            [ ReadOnly ] Dim [ WithEvents ] variablelist\n\\n
Where\n\n
        #attributelist is a list of attributes that apply to the variable. Optional.\n
        #accessmodifier defines the access levels of the variables, it has values as - Public, Protected, Friend, Protected Friend and Private. Optional.\n
        #Shared declares a shared variable, which is not associated with any specific instance of a class or structure, rather available to all the instances of the class or structure. Optional.\n
        #Shadows indicate that the variable re-declares and hides an identically named element, or set of overloaded elements, in a base class. Optional.\n
        #Static indicates that the variable will retain its value, even when the after termination of the procedure in which it is declared. Optional.\n
        #ReadOnly means the variable can be read, but not written. Optional.\n
        #WithEvents specifies that the variable is used to respond to events raised by the instance assigned to the variable. Optional.\n
        #Variablelist provides the list of variables declared.\n\n
        Some valid variable declarations along with their definition are shown here −\n\n

Dim StudentID As Integer\n
Dim StudentName As String\n
Dim Salary As Double\n
Dim count1, count2 As Integer\n
Dim status As Boolean\n
Dim exitButton As New System.Windows.Forms.Button\n
Dim lastTime, nextTime As Date\n




















    </string>
    <string name="datatypenvmet">Data types refer to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in storage and how the bit pattern stored is interpreted.\n


</string>
    <string name="datatypeexvb">VB.Net provides a wide range of data types. The following table shows all the data types available −\n

    Boolean	,Byte,Char,Date,Decimal,Double,Integer,Long	,Object,SByte,Short,Single,Strin,UInteger,ULong,User-Defined,UShort	\n\n







    </string>
    <string name="operatorsvbnet">
        An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. VB.Net is rich in built-in operators and provides following types of commonly used operators −\n

# Arithmetic Operators\n

# Comparison Operators\n

# Logical/Bitwise Operators\n

# Bit Shift Operators\n

# Assignment Operators\n

# Miscellaneous Operators\n





    </string>

</resources>
